package app

import (
	"context"
	"fmt"
	//"github.com/gin-gonic/gin"
	"github.com/mtank-group/auth-go/src/internal/kafka"
	"net"
	//"time"

	"go.uber.org/zap"
	"google.golang.org/grpc"

	"github.com/mtank-group/auth-go/src/config"
	"github.com/mtank-group/auth-go/src/internal/controller"
	pb "github.com/mtank-group/auth-go/src/internal/proto"
	"github.com/mtank-group/auth-go/src/internal/repository"
	"github.com/mtank-group/auth-go/src/internal/service"
	"github.com/mtank-group/auth-go/src/pkg/logger"
	"github.com/mtank-group/auth-go/src/pkg/postgres"
)

func Run(cfg *config.Config) {
	log := logger.New(cfg.Log.Level)

	pg, err := postgres.New(
		GetDbConnectionUrl(cfg),
	)
	if err != nil {
		log.Fatal(fmt.Sprintf("app - Run - postgres.New: %s", err.Error()))
	}
	defer pg.Close()

	err = pg.Pool.Ping(context.Background())
	if err != nil {
		log.Fatal(fmt.Sprintf("app - Run - postgres.Ping: %s", err.Error()))
	}

	// Initialize repositories and services
	userRepository := repository.NewUserRepository(pg.Pool)
	userService := service.NewUserService(userRepository, cfg.JWT.SecretKey)

	kafkaProducer, err := kafka.NewKafkaProducer(cfg.Kafka.Brokers)
	if err != nil {
		log.Fatal("failed to create Kafka producer: %v", zap.Error(err))
	}
	defer func(kafkaProducer *kafka.Producer) {
		err := kafkaProducer.Close()
		if err != nil {
			log.Fatal("failed to close Kafka producer: %v", zap.Error(err))
		}
	}(kafkaProducer)
	authController := controller.NewAuthController(userService, kafkaProducer)

	// Set up gRPC server
	grpcServer := grpc.NewServer()
	pb.RegisterAuthServiceServer(grpcServer, authController)

	lis, err := net.Listen("tcp", cfg.App.Port)
	if err != nil {
		log.Fatal("failed to listen: %v", zap.Error(err))
	}

	ctx := context.Background()
	log.Info(ctx, "server listening at %v", zap.String("address", lis.Addr().String()))

	if err := grpcServer.Serve(lis); err != nil {
		log.Fatal("failed to serve: %v", zap.Error(err))
	}
}

func GetDbConnectionUrl(cfg *config.Config) string {
	//if cfg.App.Mode != gin.TestMode {
	//	return cfg.PG.ConnectionURL()
	//}
	return cfg.DB.ConnectionURL()
	//return cfg.PG.ConnectionURLTest()
}
// Package postgres implements postgres connection.
package postgres

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/jackc/pgx/v5/pgxpool"
)

const (
	_defaultMinPoolSize  = 1
	_defaultMaxPoolSize  = 10
	_defaultConnAttempts = 10
	_defaultConnTimeout  = time.Second
	_idleTimeoutMinutes  = time.Minute * 1
)

// Postgres -.
type Postgres struct {
	Builder            squirrel.StatementBuilderType
	Pool               *pgxpool.Pool
	connTimeout        time.Duration
	idleTimeoutMinutes time.Duration
	maxPoolSize        int
	minPoolSize        int
	connAttempts       int
}

// New -.
func New(url string, opts ...Option) (*Postgres, error) {
	pg := &Postgres{
		minPoolSize:        _defaultMinPoolSize,
		maxPoolSize:        _defaultMaxPoolSize,
		connAttempts:       _defaultConnAttempts,
		connTimeout:        _defaultConnTimeout,
		idleTimeoutMinutes: _idleTimeoutMinutes,
	}

	// Custom options
	for _, opt := range opts {
		opt(pg)
	}

	pg.Builder = squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar)

	poolConfig, err := pgxpool.ParseConfig(url)
	if err != nil {
		return nil, fmt.Errorf("postgres - NewPostgres - pgxpool.ParseConfig: %w", err)
	}

	poolConfig.MinConns = int32(pg.minPoolSize)
	poolConfig.MaxConns = int32(pg.maxPoolSize)
	poolConfig.MaxConnIdleTime = pg.idleTimeoutMinutes

	for pg.connAttempts > 0 {
		pg.Pool, err = pgxpool.NewWithConfig(context.Background(), poolConfig)
		if err == nil {
			break
		}

		log.Printf("Postgres is trying to connect, attempts left: %d", pg.connAttempts)

		time.Sleep(pg.connTimeout)

		pg.connAttempts--
	}

	if err != nil {
		return nil, fmt.Errorf("postgres - NewPostgres - connAttempts == 0: %w", err)
	}

	return pg, nil
}

// Close -.
func (p *Postgres) Close() {
	if p.Pool != nil {
		p.Pool.Close()
	}
}

func (p *Postgres) Ping(ctx context.Context) error {
	err := p.Pool.Ping(ctx)
	if err != nil {
		return err
	}

	return nil
}

func CreateDatabaseIfNotExists(url, dbName string) error {
	// Подключение без указания базы данных
	pg, err := New(url)
	if err != nil {
		return fmt.Errorf("failed to connect to PostgreSQL: %w", err)
	}
	defer pg.Close()

	// Проверка существования базы данных
	var exists bool
	query := fmt.Sprintf("SELECT EXISTS(SELECT datname FROM pg_catalog.pg_database WHERE lower(datname) = lower('%s'));", dbName)
	err = pg.Pool.QueryRow(context.Background(), query).Scan(&exists)
	if err != nil {
		return fmt.Errorf("failed to check database existence: %w", err)
	}

	// Создание базы данных, если она не существует
	if !exists {
		_, err = pg.Pool.Exec(context.Background(), fmt.Sprintf("CREATE DATABASE %s", dbName))
		if err != nil {
			return fmt.Errorf("failed to create database: %w", err)
		}
	}

	return nil
}
package config

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/ilyakaznacheev/cleanenv"
)

type (
	Config struct {
		App
		Log
		Kafka
		JWT
		DB
	}

	App struct {
		Mode string `env-required:"true" env:"APP_MODE" env-upd:"true"`
		Port string `env-required:"true" env:"APP_PORT" env-upd:"true"`
	}

	Log struct {
		Level string `env-required:"true" env:"LOG_LEVEL"`
	}

	Kafka struct {
		Brokers []string `env-required:"true" env:"KAFKA_BROKERS"`
		Topic   string   `env-required:"true" env:"KAFKA_TOPIC"`
	}

	JWT struct {
		SecretKey string `env-required:"true" env:"JWT_SECRET_KEY"`
	}

	DB struct {
		Host     string `env-required:"true" env:"DB_HOST"`
		Port     string `env-required:"true" env:"DB_PORT"`
		User     string `env-required:"true" env:"DB_USER"`
		Password string `env-required:"true" env:"DB_PASSWORD"`
		DBName   string `env-required:"true" env:"DB_NAME"`
		SSLMode  string `env-required:"true" env:"DB_SSLMODE"`
	}
)

// NewConfig returns the application configuration.
func NewConfig() (*Config, error) {
	cfg := &Config{}

	err := cleanenv.ReadEnv(cfg)
	if err != nil {
		fmt.Printf("Environment variable error: %s, trying to read from .env", err.Error())
		err = cleanenv.ReadConfig(".env", cfg)
		if err != nil {
			if os.IsNotExist(err) {
				// when working directory is src/internal/tests
				err = cleanenv.ReadConfig(filepath.Join("..", "..", "..", ".env"), cfg)
			}
			if err != nil {
				return nil, err
			}
		}
	}

	flag.Parse()

	return cfg, nil
}

func (c DB) ConnectionURL() string {
	return fmt.Sprintf("postgresql://%s:%s@%s:%s/%s?sslmode=%s",
		c.User,
		c.Password,
		c.Host,
		c.Port,
		c.DBName,
		c.SSLMode,
	)
}
package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/mtank-group/auth-go/src/internal/models"
)

type UserRepository struct {
	db *pgxpool.Pool
}

func NewUserRepository(db *pgxpool.Pool) *UserRepository {
	return &UserRepository{db: db}
}

func (r *UserRepository) GetByUsername(ctx context.Context, username string) (*models.User, error) {
	query := `SELECT username, password FROM users WHERE username=$1`
	row := r.db.QueryRow(ctx, query, username)

	var user models.User
	err := row.Scan(&user.Username, &user.Password)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

func (r *UserRepository) CreateUser(ctx context.Context, user *models.User) error {
	query := `INSERT INTO users (username, password) VALUES ($1, $2)`
	_, err := r.db.Exec(ctx, query, user.Username, user.Password)
	return err
}
package controller

import (
	"context"
	"github.com/mtank-group/auth-go/src/internal/kafka"
	"github.com/mtank-group/auth-go/src/internal/proto"
	"github.com/mtank-group/auth-go/src/internal/service"
)

type AuthController struct {
	proto.UnimplementedAuthServiceServer
	userService   *service.UserService
	kafkaProducer *kafka.Producer
}

func NewAuthController(userService *service.UserService, kafkaProducer *kafka.Producer) *AuthController {
	return &AuthController{
		userService:   userService,
		kafkaProducer: kafkaProducer,
	}
}

func (c *AuthController) Authenticate(ctx context.Context, req *proto.AuthRequest) (*proto.AuthResponse, error) {
	user, err := c.userService.Authenticate(req.Username, req.Password)
	if err != nil {
		return &proto.AuthResponse{
			Success: false,
			Message: "Authentication failed",
		}, err
	}

	token, err := c.userService.GenerateJWT(user)
	if err != nil {
		return &proto.AuthResponse{
			Success: false,
			Message: "Failed to generate token",
		}, err
	}

	err = c.kafkaProducer.SendMessage("user-authenticated", user.Username)
	if err != nil {
		return &proto.AuthResponse{
			Success: false,
			Message: "Failed to send Kafka message",
		}, err
	}

	return &proto.AuthResponse{
		Token:   token,
		Success: true,
		Message: "Authenticated",
	}, nil
}
package models

type User struct {
	Username string
	Password string
}
package service

import (
	"errors"
	"time"

	"github.com/golang-jwt/jwt/v4"
	"github.com/mtank-group/auth-go/src/internal/models"
	"github.com/mtank-group/auth-go/src/internal/repository"
)

type UserService struct {
	userRepo  *repository.UserRepository
	secretKey string
}

func NewUserService(userRepo *repository.UserRepository, secretKey string) *UserService {
	return &UserService{
		userRepo:  userRepo,
		secretKey: secretKey,
	}
}

func (s *UserService) Authenticate(username, password string) (*models.User, error) {
	user, err := s.userRepo.GetByUsername(username)
	if err != nil {
		return nil, err
	}

	if user.Password != password {
		return nil, errors.New("invalid username or password")
	}

	return user, nil
}

func (s *UserService) GenerateJWT(user *models.User) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"username": user.Username,
		"exp":      time.Now().Add(time.Hour * 72).Unix(),
	})
	return token.SignedString([]byte(s.secretKey))
}

func (s *UserService) RegisterUser(username, password string) error {
	return s.userRepo.CreateUser(&models.User{Username: username, Password: password})
}